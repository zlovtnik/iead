name: Church Management CI/CD Pipeline

on:
  push:
    branches: [ main, develop, 'release/*' ]
  pull_request:
    branches: [ main ]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/church-management
  NODE_VERSION: '18'
  LUA_VERSION: '5.1'

jobs:
  # Code Quality and Security (runs first)
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    outputs:
      quality-passed: ${{ steps.quality-check.outputs.passed }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: public/package-lock.json

    - name: Setup Lua Environment
      uses: leafo/gh-actions-lua@v10
      with:
        luaVersion: ${{ env.LUA_VERSION }}

    - name: Install Dependencies
      run: |
        cd public && npm ci
        sudo apt-get update
        sudo apt-get install -y luarocks sqlite3
        luarocks install luacheck
        luarocks install busted

    - name: Run Quality Checks
      id: quality-check
      run: |
        chmod +x scripts/run_quality_checks.sh
        if scripts/run_quality_checks.sh; then
          echo "passed=true" >> $GITHUB_OUTPUT
        else
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Upload Quality Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: quality-reports
        path: quality-reports/

  # Build and Test
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: quality-gate
    if: needs.quality-gate.outputs.quality-passed == 'true'
    
    strategy:
      matrix:
        environment: [development, staging, production]
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ matrix.environment }}-latest,enable={{is_default_branch}}

    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          ENVIRONMENT=${{ matrix.environment }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ github.ref_name }}

    - name: Run Security Scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Security Scan Results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [quality-gate, build]
    if: needs.quality-gate.outputs.quality-passed == 'true'
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Pull Docker Image
      run: |
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

    - name: Setup Test Environment
      run: |
        cp .env.production.template .env.test
        sed -i 's/your-super-secure-session-secret-here-at-least-32-chars/test-session-secret-32-characters-long/g' .env.test
        sed -i 's/your-super-secure-jwt-secret-here-at-least-32-chars/test-jwt-secret-32-characters-long/g' .env.test
        sed -i 's/redis:\/\/redis:6379/redis:\/\/localhost:6379/g' .env.test

    - name: Run Application Container
      run: |
        docker run -d \
          --name church-management-test \
          --env-file .env.test \
          -p 8080:8080 \
          --network host \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

    - name: Wait for Application
      run: |
        timeout 60 bash -c 'until curl -f http://localhost:8080/api/health; do sleep 5; done'

    - name: Run Integration Tests
      run: |
        # Run API tests
        curl -f http://localhost:8080/api/health
        
        # Test authentication endpoints
        curl -X POST http://localhost:8080/api/auth/login \
          -H "Content-Type: application/json" \
          -d '{"email":"test@example.com","password":"testpass"}'
        
        # Test member endpoints
        curl -f http://localhost:8080/api/members
        
        echo "Integration tests passed!"

    - name: Collect Application Logs
      if: always()
      run: |
        docker logs church-management-test > app-logs.txt

    - name: Upload Integration Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: integration-test-results
        path: |
          app-logs.txt

  # Staging Deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, integration-tests]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

    - name: Deploy to Staging Server
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
          cd /opt/church-management
          
          # Backup current version
          docker-compose -f docker-compose.staging.yml down
          
          # Pull latest code and images
          git pull origin develop
          docker-compose -f docker-compose.staging.yml pull
          
          # Run database migrations
          docker-compose -f docker-compose.staging.yml run --rm app lua scripts/migrate.lua migrate
          
          # Start services
          docker-compose -f docker-compose.staging.yml up -d
          
          # Health check
          sleep 30
          curl -f http://localhost:8080/api/health || exit 1
          
          echo "Staging deployment successful!"
        EOF

    - name: Run Staging Tests
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
          # Run smoke tests on staging
          curl -f http://staging.church.yourdomain.com/api/health
          curl -f http://staging.church.yourdomain.com/
          echo "Staging tests passed!"
        EOF

    - name: Notify Staging Deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: "Staging deployment completed: ${{ github.sha }}"

  # Production Deployment
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

    - name: Create Production Backup
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          cd /opt/church-management
          
          # Create backup
          backup_name="backup-$(date +%Y%m%d_%H%M%S)"
          mkdir -p backups/$backup_name
          
          # Backup database
          docker-compose -f docker-compose.production.yml exec -T app \
            sqlite3 /app/data/church_management.db ".backup /app/backups/$backup_name/database.db"
          
          # Backup uploads
          cp -r uploads backups/$backup_name/
          
          echo "Backup created: $backup_name"
        EOF

    - name: Deploy to Production
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          cd /opt/church-management
          
          # Pull latest code and images
          git pull origin main
          docker-compose -f docker-compose.production.yml pull
          
          # Run database migrations
          docker-compose -f docker-compose.production.yml run --rm app lua scripts/migrate.lua migrate
          
          # Rolling update
          docker-compose -f docker-compose.production.yml up -d --scale app=2
          sleep 30
          
          # Health check
          curl -f http://localhost:8080/api/health || exit 1
          
          echo "Production deployment successful!"
        EOF

    - name: Run Production Health Checks
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
          # Comprehensive health checks
          curl -f https://church.yourdomain.com/api/health
          curl -f https://church.yourdomain.com/
          
          # Check monitoring services
          curl -f http://localhost:9090/api/v1/query?query=up
          curl -f http://localhost:3000/api/health
          
          echo "Production health checks passed!"
        EOF

    - name: Notify Production Deployment
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: "ðŸš€ Production deployment completed: ${{ github.sha }}"

  # Performance Testing (runs after production deployment)
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Run Performance Tests
      run: |
        # Install k6 for load testing
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
        
        # Run load tests
        k6 run --vus 10 --duration 60s scripts/k6-performance-test.js

    - name: Upload Performance Results
      uses: actions/upload-artifact@v4
      with:
        name: performance-test-results
        path: performance-results.json

  # Security Monitoring Setup
  security-monitoring:
    name: Security Monitoring
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Setup Security Monitoring
      run: |
        # Trigger security scans
        curl -X POST "${{ secrets.SECURITY_WEBHOOK_URL }}" \
          -H "Authorization: Bearer ${{ secrets.SECURITY_TOKEN }}" \
          -d '{"action": "scan", "target": "https://church.yourdomain.com"}'

  # Cleanup
  cleanup:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: Cleanup Container Registry
      run: |
        # Keep last 10 images, delete older ones
        echo "Cleanup would run here - implement based on your registry"
